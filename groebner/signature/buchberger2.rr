extern MyVar;

def spolynomial(F,G, ORD) {
    DF = multi_degree(F, ORD);
    DG = multi_degree(G, ORD);
    
    C1 = 1 / DF[length(MyVar)];
    C2 = -1 / DG[length(MyVar)];
    for(I = 0; I < length(MyVar); I++) {
      M = DF[I]>DG[I]?DF[I]:DG[I];
      C1 = C1 * MyVar[I]^(M - DF[I]);
      C2 = C2 * MyVar[I]^(M - DG[I]);
    }
    //Mx = DF[0]>DG[0]?DF[0]:DG[0];
    //My = DF[1]>DG[1]?DF[1]:DG[1];
    //Mz = DF[2]>DG[2]?DF[2]:DG[2];
    

    //CC = [x^(Mx-DF[0])*y^(My-DF[1])*z^(Mz-DF[2])/DF[3], -x^(Mx-DG[0])*y^(My-DG[1])*z^(Mz-DG[2])/DG[3]];
    CC = [C1, C2];

    //return [x^(Mx-DF[0])*y^(My-DF[1])*z^(Mz-DF[2])*F/DF[3]-x^(Mx-DG[0])*y^(My-DG[1])*z^(Mz-DG[2])*G/DG[3], CC];
    return [C1*F + C2*G , CC];
}

def buchberger(F, ORD) {
    N = length(F);
    Pairs = [];
    
    for ( I = N-1; I >= 0; I-- ) {
        for ( J = N-1; J > I; J-- ) {
            Pairs = cons([I,J],Pairs);
        }
    }
    
    G = F;

    NEWC = [];
    while ( Pairs != [] ) {
        P = car(Pairs);
        Pairs = cdr(Pairs);
        Sp = spolynomial(G[P[0]],G[P[1]], ORD);
        Rem = reduction2(Sp[0],G, ORD);
        if ( Rem[1] ) {
            // 行列の初期化
            CCC = [];
            for ( I = 0; I < N+CNT; I++ ) {
                CC = [];
                for ( J = 0; J < N+CNT; J++ ) {
                    if (I == J) {
                        CC = append(CC, [1]);
                    }
                    else {
                        CC = append(CC, [0]);
                    }
                }
                CCC = append(CCC, [CC]);
            }


            // 新しい行の作成
            CC = [];
            for ( I = 0; I < length(G); I++ ) {
                if(I == P[0]) {
                    CC = append(CC, [Sp[1][0] - Rem[0][I]]);
                }
                else if (I == P[1]) {
                        CC = append(CC, [Sp[1][1] - Rem[0][I]]);
                }
                else {
                    CC = append(CC, [(-1) * Rem[0][I]]);
                }
            }
            CCC = append(CCC, [CC]);
            
            // 行列の決定
            if (length(G) == length(F)) {
                NEWC = matrix_list_to_matrix(CCC);
                //NEWC = ltov(CCC);
            }
            else {
                NEWC = matrix_list_to_matrix(CCC) * NEWC;
                //TEMP = ltov(CCC);
                //print(TEMP);
                //print(ltov(TEMP[0]));
                //print(NEWC);
                //NEWC = TEMP * NEWC;
            }

            // Gの更新
            G = append(G,[Rem[1]]);
            //print(C);
            for ( I = 0; I < N; I++ ) {
                Pairs = cons([I,N],Pairs);
            }
            N++;
        }
    }
    
    C = matrix_matrix_to_list(NEWC);

    if(C == []) {
      C = matrix_matrix_to_list( matrix_identity_matrix(N) );
    }
    // C = vtol(NEWC);
    return [G, C];
}

def minimal(G, C, ORD) {
    N = length(G);
    
    MG = [];
    CC = [];
    for(I = 0; I < N; I++) {
        GG = [];
        for(J = 0; J < N; J++) {
            if(I != J) {
                PP = in(G[J], ORD);
                GG = append(GG, [PP[0]]);
            }
        }

        PP = in(G[I], ORD);
        RR = reduction2(PP[0],GG, ORD);
        if(RR[1] != 0) {
            MG = append(MG, [G[I]]);
            CC = append(CC, [C[I]]);
        }
    }

    return [MG, CC];
    //return [MG, CC];
}

def reduce(G, C, ORD) {
    MG = minimal(G, C, ORD);
    N = length(MG[0]);

    MG2 = [];
    CC = [];
    for(I = 0; I < N; I++) {
        CCC = newvect(N);
        PPP = in(MG[0][I], ORD);
        MG2 = append(MG2, [MG[0][I]/PPP[1]]);
        for(J = 0; J < N; J++) {
            if(I == J) {
                CCC[I] = 1/PPP[1];
            }
        }
        CC = append(CC, [matrix_matrix_to_list(CCC)]);
    }

    C2 = matrix_list_to_matrix(CC);

    RG = [];
    CC = [];
    for(I = 0; I < N; I++) {
        CCC = newvect(N);
        for(J = 0; J < N; J++) {
            if(I == J) {
                CCC[I] = 1;
            }
        }
        PPP = MG2[I];
        NEWP = 0;

        while(PPP != 0) {
            INP = in(PPP, ORD);
            for(J = 0; J < N; J++) {
                if(I == J) {
                    J = J + 1;
                }
                if(J >= N) {
                    break;
                }

                INQ = in(MG2[J], ORD);
                JUDGE = is_reducible(INP[0],INQ[0],ORD);
                if(JUDGE != 0) {
                    PPP = PPP - JUDGE*MG2[J];
                    for(K = 0; K < N; K++) {
                        if(K == J) {
                            CCC[J] = CCC[J] - JUDGE;
                        }
                        /*
                        else {
                            CCC = append(CCC, [0]);
                        }
                        */
                    }
                    break;
                }
                else {
                    if(J >= N-1 || (J >= N-2 && I >= N-1)) {
                        NEWP = NEWP + INP[0];
                        PPP = PPP - INP[0];
                        break;
                    }
                }
            }
        }

        CC = append(CC, [matrix_matrix_to_list(CCC)]);
        
        RG = append(RG, [NEWP]);
    }

    C1 = matrix_list_to_matrix(CC);
    C3 = matrix_list_to_matrix(MG[1]);
    CC = C1 * C2;
    CC = CC * C3;
    CR = matrix_matrix_to_list(CC);

    return [RG, CR];
}

end$
