\documentclass[a4j]{jarticle}

\usepackage{amsmath, amssymb}
\usepackage{ascmac}
\usepackage{bm}
\usepackage{here}
\usepackage{url}
\usepackage{amsthm}
\usepackage{listings, jlisting}
\usepackage{verbatim}
\usepackage[dvipdfmx]{graphicx}


%\usepackage{txfonts}
%\usepackage{listings, jlisting}
\if0
\renewcommand{\lstlistingname}{リスト}
\lstset{language=Python,
  basicstyle=\ttfamily\scriptsize,
  commentstyle=\textit,
  classoffset=1,
  keywordstyle=\bfseries,
  frame=tRBl,
  framesep=5pt,
  showstringspaces=false,
  numbers=left,
  stepnumber=1,
  numberstyle=\tiny,
  tabsize=2
}
\fi

\newcommand{\setlen}{
	\setlength{\parskip}{1.2pt} % 段落間
	\setlength{\itemsep}{1.2pt} % 項目間
}
%\newcommand{\setlen}{\setlength{\parskip}{0cm} 	\setlength{\itemsep}{0cm}}
\if 0
\newcommand{\KP}{k[x_1, x_2, \cdots, x_n]}
\newcommand{\LT}{{\rm LT}}
\newcommand{\LM}{{\rm LM}}
\newcommand{\LC}{{\rm LC}}
\newcommand{\RT}{{\rm RT}}
\newcommand{\Sect}{\S}
\renewcommand{\S}{{\rm S}}
\newcommand{\T}{{\rm T}}
\newcommand{\LCM}{{\rm LCM}}
\newcommand{\M}{{\rm M}}

\def\vector#1{\mbox{\boldmath $#1$}}
\fi


\makeatletter
\def\section{\@startsection {section}{1}{\z@}{-2.5ex plus -1ex minus -.2ex}{2.5 ex plus .2ex}{\Large\bf}}
\def\subsection{\@startsection {subsection}{1}{\z@}{-1.5ex plus -1ex minus -.2ex}{2.3 ex plus .2ex}{\large\bf}}
\def\subsubsection{\@startsection {subsubsection}{1}{\z@}{-2.5ex plus -1ex minus -.2ex}{.3 ex plus .2ex}{\normalsize \bf $\spadesuit$ }}
\makeatother


\makeatletter

\def\@thesis{テーマ\ \ とか}
\def\id#1{\def\@id{#1}}
\def\department#1{\def\@department{#1}}

\def\@maketitle{
\begin{center}
{\LARGE \@thesis \par} % 
\vspace{10mm}
{\LARGE\bf \@title \par}% 
\vspace{10mm}
{\Large \@date\par} % 
\vspace{20mm}
{\Large \@department \par}  % 
{\Large   \@id \par} % 
\vspace{10mm}
{\large \@author}%  
\end{center}
\par\vskip 1.5em
}

\makeatother

\title{Asirによる図形描画}
\date{\today}
\department{所属}
\id{id}
\author{氏名}




\begin{document}
\maketitle
\thispagestyle{empty}

\newpage
\addtocounter{page}{-1}


\section{目的}
\hspace{1em}本課題は, Asirのライブラリ「glib3.rr」を用いての図形の作成と描画を行い, 
また, 関数の理解を始めとしたプログラミングの基礎を学ぶことを目的とする. \par

\section{作成した図形}
\hspace{1em}本課題では, 関数を理解するという目的から, 
関数を利用することで簡単に作図できるフラクタル図形を
題材として選択した. \par
作図したフラクタル図形は, 
二分木のフラクタルとシェルピンスキーのギャスケットの2つである. 
今回の作図に用いたソースコードを付録に, 
作図したフラクタル図形を図1に示す. 
\begin{figure}[H]
	\begin{center}
  	\includegraphics[width=15cm]{result.png}
    \caption{作図したフラクタル図形}      
  \end{center}
\end{figure}

\section{各関数の仕様}
  \hspace{1em}作成した関数の仕様をまとめていく. 
  \subsection{dist}
    関数 : dist(Px, Py, Qx, Qy) \\
    機能 : 2点間の距離を計算する. \\
    引数 : 1点目の$x$座標, $y$座標, 2点目の$x$座標, $y$座標 \\
    戻り値 : 1点目と2点目の間の距離

  \subsection{cent}
    関数 : cent(A, B) \\
    機能 : 2数の平均を計算する(中点を計算する). \\
    引数 : 数1, 数2\\
    戻り値 : 数1と数2の平均(中点)

  \subsection{rot\_vec}
    関数 : rot\_vec(P, T) \\
    機能 : 2次元ベクトルを回転する. \\
    引数 : 2次元ベクトル(配列), 回転角\\
    戻り値 : 回転させた2次元ベクトル

  \subsection{sum\_vec}
    関数 : sum\_vec(P, Q) \\
    機能 : 2次元ベクトルの和を計算する(ベクトルPをQ平行移動する). \\
    引数 : 2次元ベクトルP, Q \\
    戻り値 : 2次元ベクトルP+Q

  \subsection{scala\_mul}
    関数 : scala\_mul(P, S) \\
    機能 : 2次元ベクトルをスカラー倍する. \\
    引数 : 2次元ベクトルP, 実数S \\
    戻り値 : 2次元ベクトルSP

  \subsection{dire\_vec}
    関数 : dire\_vec(Pl, Ql) \\
    機能 : 2つの座標から方向ベクトルを求める. \\
    引数 : 座標1(2次元配列), 座標2(2次元配列) \\
    戻り値 : 座標1から座標2への方向ベクトル

  \subsection{triangle}
    関数 : triangle(Ax, Ay, Bx, By, Cx, Cy) \\
    機能 : 3点を結んでできる三角形を描く. \\
    引数 : 点Aの$x$座標, $y$座標, 点Bの$x$座標,  $y$座標, 点Cの$x$座標, $y$座標 \\
    戻り値 : なし

  \subsection{fractal\_tri}
    関数 : fractal\_tri(Px, Py, Qx, Qy, Rx, Ry) \\
    機能 : シェルピンスキーのギャスケットを描く \\
    引数 : 一番大きい三角形の3つの$x$, $y$座標 \\
    戻り値 : なし

  \subsection{fractal\_tree}
    関数 : fractal\_tree \\
    機能 : 二分木のフラクタルを描く. \\
    引数 : 最初の枝の端点の座標(2次元配列)2つ, 2次元配列[0, 0], 枝同士のなす角 \\
    戻り値 : なし


\newpage
\section*{付録}
%\begin{lstlisting}[tabsize = 2, basicstyle=\footnotesize, numbers=left, breaklines=true]
\begin{lstlisting}[caption=2つのフラクタル図形を作図するプログラム, tabsize = 2, basicstyle=\footnotesize, frame=single, numbers=left, breaklines=true]
import("glib3.rr");

/* calculate distance between point P and point Q */
def dist(Px, Py, Qx, Qy) {
  return((Px-Qx)^2 + (Py-Qy)^2);
}

/* calculate center of two points */
def cent(A, B) {
  return((A+B)/2);
}

/* rotation */
def rot_vec(P, T) {
  Q = [deval(P[0]*cos(T)-P[1]*sin(T)), deval(P[0]*sin(T)+P[1]*cos(T))];
  return(Q);
}

/* translation */
def sum_vec(P, Q) {
  R = [P[0]+Q[0], P[1]+Q[1]];
  return(R);
}

/* scala multiple */
def scala_mul(P, S) {
  Q = [S*P[0], S*P[1]];
  return(Q);
}

/* calculate direction vector */
def dire_vec(Pl, Ql) {
  R = [Ql[0] - Pl[0], Ql[1] - Pl[1]];
  return(R);
}


/* function drawing triangle */
def triangle(Ax, Ay, Bx, By, Cx, Cy) {
  glib_line(Ax, Ay, Bx, By);
  glib_line(Bx, By, Cx, Cy);
  glib_line(Cx, Cy, Ax, Ay);
}


/*------------------------------------*/
/* function drawing fractal-triangle  */
/* input: (triangle's coordinate)     */
/* process: draw fractal-triangle     */
/*------------------------------------*/
def fractal_tri(Px, Py, Qx, Qy, Rx, Ry) {
  
  /* draw triangle */
  triangle(Px, Py, Qx, Qy, Rx, Ry);

  /* end judge */
  if(dist(Px, Py, Qx, Qy) < 0.01) {
    ;
  }
  else {
    /* up triangle */
    fractal_tri(Px, Py, cent(Px,Qx), cent(Py,Qy), cent(Rx,Px), cent(Ry,Py));
    /* left triangle */
    fractal_tri(cent(Px,Qx), cent(Py,Qy), Qx, Qy, cent(Rx,Qx), cent(Ry,Qy));
    /* right triangle */
    fractal_tri(cent(Px,Rx), cent(Py,Qy), cent(Rx,Qx), cent(Ry,Qy), Rx, Ry);
  }
}


/*--------------------------------------------------------*/
/* function drawing fractal-tree                          */
/* input: (init branches' coordinate, theta of branches)  */
/* process: draw fractal-tree                             */
/*--------------------------------------------------------*/
def fractal_tree(P, Q, S, T) {

  /* draw branch */
  if(dist(P[0], P[1], Q[0], Q[1]) < 0.01) {
    glib_line(P[0], P[1], Q[0], Q[1] | color = 0x50cf80);
  }
  else {
    glib_line(P[0], P[1], Q[0], Q[1] | color = 0xcf8030);
  }

  /* set parameter for branch */
  D = dire_vec(P, Q); /* direction of old branch */
  S = sum_vec(S, D);  /* start position of new branch */
  
  /* Right branch */
  R = scala_mul(D, 2/3);  /* update length of new branch */
  R = rot_vec(R, T);      /* rotate branch */
  Right = sum_vec(S, R);  /* calculate new branch */
  
  /* Left branch (in the same right's way) */
  L = scala_mul(D, 2/3);
  L = rot_vec(L, -T);
  Left = sum_vec(S, L);

  /* end judge */
  if(dist(P[0], P[1], Q[0], Q[1]) < 0.001) {
    ;
  }
  else {
    /* right tree */
    fractal_tree(Q, Right, S, T);
    /* left tree */
    fractal_tree(Q, Left, S, T);
  }
}



/* from here, main (function ?) */

/* initiallize window */
Glib_math_coordinate=1;
glib_window(-5,-1,12,7);
glib_clear();


/* set coordinate of tree */
P = [0, 0];
Q = [0, 2];
S = [0, 0];
Theta = deval(@pi/5);

/* draw fractal-tree */
fractal_tree(P, Q, S, Theta);


/* set coordinate of triangle */
Px = 8;
Py = 6;
Qx = deval(Px-2*3^(1/2));
Qy = 0;
Rx = deval(Px+2*3^(1/2));
Ry = 0;

/* draw fractal-triangle */
fractal_tri(Px, Py, Qx, Qy, Rx, Ry);

/* draw on window */
glib_flush();
\end{lstlisting}


\end{document}
